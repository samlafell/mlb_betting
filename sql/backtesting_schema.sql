-- Backtesting and Strategy Performance Schema
-- This schema stores historical backtesting results, strategy performance metrics,
-- and threshold recommendations for the automated system

-- Create backtesting schema
CREATE SCHEMA IF NOT EXISTS backtesting;

-- Strategy Performance History Table
-- Stores daily backtesting results for each strategy
CREATE TABLE IF NOT EXISTS backtesting.strategy_performance (
    id VARCHAR PRIMARY KEY,
    backtest_date DATE NOT NULL,
    strategy_name VARCHAR NOT NULL,
    source_book_type VARCHAR NOT NULL,
    split_type VARCHAR NOT NULL,
    
    -- Performance Metrics
    total_bets INTEGER NOT NULL,
    wins INTEGER NOT NULL,
    win_rate DOUBLE NOT NULL,
    roi_per_100 DOUBLE NOT NULL,
    
    -- Statistical Metrics
    sharpe_ratio DOUBLE,
    max_drawdown DOUBLE,
    confidence_interval_lower DOUBLE,
    confidence_interval_upper DOUBLE,
    sample_size_adequate BOOLEAN,
    statistical_significance BOOLEAN,
    p_value DOUBLE,
    
    -- Trend Analysis
    seven_day_win_rate DOUBLE,
    thirty_day_win_rate DOUBLE,
    trend_direction VARCHAR, -- 'improving', 'declining', 'stable'
    
    -- Risk Metrics
    consecutive_losses INTEGER DEFAULT 0,
    volatility DOUBLE DEFAULT 0.0,
    kelly_criterion DOUBLE DEFAULT 0.0,
    
    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Threshold Recommendations Table
-- Stores automated recommendations for strategy threshold adjustments
CREATE TABLE IF NOT EXISTS backtesting.threshold_recommendations (
    id VARCHAR PRIMARY KEY,
    recommendation_date DATE NOT NULL,
    strategy_name VARCHAR NOT NULL,
    
    -- Threshold Details
    current_threshold DOUBLE NOT NULL,
    recommended_threshold DOUBLE NOT NULL,
    threshold_type VARCHAR NOT NULL, -- 'strong', 'moderate', 'weak'
    
    -- Justification
    confidence_level VARCHAR NOT NULL, -- 'HIGH', 'MEDIUM', 'LOW'
    justification TEXT NOT NULL,
    expected_improvement DOUBLE,
    risk_assessment VARCHAR, -- 'LOW', 'MEDIUM', 'HIGH'
    
    -- Sample Data
    sample_size INTEGER NOT NULL,
    current_win_rate DOUBLE,
    current_roi DOUBLE,
    
    -- Implementation Details
    file_path VARCHAR NOT NULL,
    line_number INTEGER,
    variable_name VARCHAR,
    
    -- Status
    status VARCHAR DEFAULT 'PENDING', -- 'PENDING', 'APPROVED', 'REJECTED', 'APPLIED'
    requires_human_approval BOOLEAN DEFAULT TRUE,
    applied_at TIMESTAMP,
    applied_by VARCHAR,
    
    -- Safety Controls
    cooling_period_required BOOLEAN DEFAULT FALSE,
    cooling_period_end TIMESTAMP,
    
    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Alert History Table
-- Stores all alerts generated by the system
CREATE TABLE IF NOT EXISTS backtesting.alert_history (
    id VARCHAR PRIMARY KEY,
    alert_type VARCHAR NOT NULL,
    severity VARCHAR NOT NULL,
    title VARCHAR NOT NULL,
    message TEXT NOT NULL,
    
    -- Context
    strategy_name VARCHAR,
    source_book_type VARCHAR,
    
    -- Alert Data (JSON)
    data JSON,
    
    -- Status
    acknowledged_at TIMESTAMP,
    resolved_at TIMESTAMP,
    escalated BOOLEAN DEFAULT FALSE,
    escalation_level INTEGER DEFAULT 0,
    
    -- Actions
    action_required BOOLEAN DEFAULT FALSE,
    action_description TEXT,
    action_taken TEXT,
    action_taken_at TIMESTAMP,
    
    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Backtesting Run History
-- Stores metadata about each backtesting pipeline execution
CREATE TABLE IF NOT EXISTS backtesting.run_history (
    id VARCHAR PRIMARY KEY,
    run_date DATE NOT NULL,
    run_type VARCHAR NOT NULL, -- 'daily', 'weekly', 'manual', 'test'
    
    -- Execution Details
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP,
    execution_time_seconds DOUBLE,
    status VARCHAR NOT NULL, -- 'running', 'completed', 'failed', 'cancelled'
    
    -- Results Summary
    strategies_analyzed INTEGER DEFAULT 0,
    strategies_with_adequate_data INTEGER DEFAULT 0,
    profitable_strategies INTEGER DEFAULT 0,
    declining_strategies INTEGER DEFAULT 0,
    threshold_recommendations_generated INTEGER DEFAULT 0,
    alerts_generated INTEGER DEFAULT 0,
    
    -- Data Quality
    data_completeness_pct DOUBLE,
    game_outcome_freshness_hours DOUBLE,
    
    -- Error Information
    error_message TEXT,
    error_details JSON,
    
    -- Configuration Used
    config_snapshot JSON,
    
    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Strategy Threshold History
-- Tracks all threshold changes over time
CREATE TABLE IF NOT EXISTS backtesting.threshold_history (
    id VARCHAR PRIMARY KEY,
    change_date DATE NOT NULL,
    strategy_name VARCHAR NOT NULL,
    threshold_type VARCHAR NOT NULL,
    
    -- Change Details
    old_value DOUBLE NOT NULL,
    new_value DOUBLE NOT NULL,
    change_percent DOUBLE, -- Calculated: (new - old) / old * 100
    
    -- Justification
    change_reason VARCHAR NOT NULL, -- 'automated', 'manual', 'emergency'
    recommendation_id VARCHAR, -- Link to threshold_recommendations table
    justification TEXT,
    
    -- Performance Context
    previous_performance JSON, -- Win rate, ROI, etc. before change
    expected_improvement DOUBLE,
    
    -- Implementation
    applied_by VARCHAR, -- 'system' or user identifier
    file_modified VARCHAR,
    line_modified INTEGER,
    
    -- Results Tracking
    performance_after_change JSON, -- To be updated later
    actual_improvement DOUBLE, -- To be calculated after sufficient data
    
    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Performance Trends View
-- Aggregated view for trend analysis
CREATE VIEW backtesting.performance_trends AS
WITH daily_performance AS (
    SELECT 
        strategy_name,
        source_book_type,
        split_type,
        backtest_date,
        win_rate,
        roi_per_100,
        total_bets,
        ROW_NUMBER() OVER (
            PARTITION BY strategy_name, source_book_type, split_type 
            ORDER BY backtest_date DESC
        ) as days_ago
    FROM backtesting.strategy_performance
    WHERE backtest_date >= CURRENT_DATE - INTERVAL '90 days'
)
SELECT 
    strategy_name,
    source_book_type,
    split_type,
    
    -- Current Performance (latest)
    MAX(CASE WHEN days_ago = 1 THEN win_rate END) as current_win_rate,
    MAX(CASE WHEN days_ago = 1 THEN roi_per_100 END) as current_roi,
    MAX(CASE WHEN days_ago = 1 THEN total_bets END) as current_total_bets,
    
    -- 7-day averages
    AVG(CASE WHEN days_ago <= 7 THEN win_rate END) as avg_7d_win_rate,
    AVG(CASE WHEN days_ago <= 7 THEN roi_per_100 END) as avg_7d_roi,
    SUM(CASE WHEN days_ago <= 7 THEN total_bets END) as total_7d_bets,
    
    -- 30-day averages
    AVG(CASE WHEN days_ago <= 30 THEN win_rate END) as avg_30d_win_rate,
    AVG(CASE WHEN days_ago <= 30 THEN roi_per_100 END) as avg_30d_roi,
    SUM(CASE WHEN days_ago <= 30 THEN total_bets END) as total_30d_bets,
    
    -- Trend calculations
    CASE 
        WHEN AVG(CASE WHEN days_ago <= 7 THEN win_rate END) > 
             AVG(CASE WHEN days_ago BETWEEN 8 AND 14 THEN win_rate END) + 0.02 
        THEN 'improving'
        WHEN AVG(CASE WHEN days_ago <= 7 THEN win_rate END) < 
             AVG(CASE WHEN days_ago BETWEEN 8 AND 14 THEN win_rate END) - 0.02 
        THEN 'declining'
        ELSE 'stable'
    END as trend_direction,
    
    -- Volatility (standard deviation of win rates)
    STDDEV(CASE WHEN days_ago <= 30 THEN win_rate END) as volatility_30d,
    
    -- Data availability
    COUNT(CASE WHEN days_ago <= 7 THEN 1 END) as days_with_data_7d,
    COUNT(CASE WHEN days_ago <= 30 THEN 1 END) as days_with_data_30d,
    
    MAX(backtest_date) as last_updated
    
FROM daily_performance
GROUP BY strategy_name, source_book_type, split_type
HAVING COUNT(*) >= 5; -- Minimum 5 days of data

-- Alert Summary View
-- Quick view of alert patterns and frequencies
CREATE VIEW backtesting.alert_summary AS
SELECT 
    alert_type,
    severity,
    strategy_name,
    
    -- Counts
    COUNT(*) as total_alerts,
    COUNT(CASE WHEN created_at >= CURRENT_DATE - INTERVAL '7 days' THEN 1 END) as alerts_7d,
    COUNT(CASE WHEN created_at >= CURRENT_DATE - INTERVAL '30 days' THEN 1 END) as alerts_30d,
    
    -- Status
    COUNT(CASE WHEN acknowledged_at IS NOT NULL THEN 1 END) as acknowledged_count,
    COUNT(CASE WHEN resolved_at IS NOT NULL THEN 1 END) as resolved_count,
    COUNT(CASE WHEN action_required = TRUE THEN 1 END) as action_required_count,
    
    -- Timing
    MIN(created_at) as first_alert,
    MAX(created_at) as last_alert,
    AVG(EXTRACT('epoch' FROM (COALESCE(acknowledged_at, CURRENT_TIMESTAMP) - created_at)) / 3600) as avg_response_time_hours,
    
    -- Recent activity
    MAX(CASE WHEN created_at >= CURRENT_DATE - INTERVAL '1 day' THEN created_at END) as last_24h_alert
    
FROM backtesting.alert_history
WHERE created_at >= CURRENT_DATE - INTERVAL '90 days'
GROUP BY alert_type, severity, strategy_name;

-- Recommendation Success Tracking View
-- Tracks the effectiveness of threshold recommendations
CREATE VIEW backtesting.recommendation_effectiveness AS
WITH recommendation_results AS (
    SELECT 
        tr.id,
        tr.strategy_name,
        tr.current_threshold,
        tr.recommended_threshold,
        tr.expected_improvement,
        tr.current_win_rate,
        tr.current_roi,
        tr.applied_at,
        tr.status,
        
        -- Performance before recommendation (30 days before applied_at)
        AVG(CASE 
            WHEN sp.backtest_date BETWEEN DATE(tr.applied_at) - INTERVAL '30 days' 
                                      AND DATE(tr.applied_at) - INTERVAL '1 day'
            THEN sp.win_rate 
        END) as win_rate_before,
        
        AVG(CASE 
            WHEN sp.backtest_date BETWEEN DATE(tr.applied_at) - INTERVAL '30 days' 
                                      AND DATE(tr.applied_at) - INTERVAL '1 day'
            THEN sp.roi_per_100 
        END) as roi_before,
        
        -- Performance after recommendation (30 days after applied_at)
        AVG(CASE 
            WHEN sp.backtest_date BETWEEN DATE(tr.applied_at) + INTERVAL '1 day'
                                      AND DATE(tr.applied_at) + INTERVAL '30 days'
            THEN sp.win_rate 
        END) as win_rate_after,
        
        AVG(CASE 
            WHEN sp.backtest_date BETWEEN DATE(tr.applied_at) + INTERVAL '1 day'
                                      AND DATE(tr.applied_at) + INTERVAL '30 days'
            THEN sp.roi_per_100 
        END) as roi_after
        
    FROM backtesting.threshold_recommendations tr
    LEFT JOIN backtesting.strategy_performance sp 
        ON tr.strategy_name = sp.strategy_name
        AND sp.backtest_date BETWEEN DATE(tr.applied_at) - INTERVAL '30 days'
                                 AND DATE(tr.applied_at) + INTERVAL '30 days'
    WHERE tr.status = 'APPLIED'
      AND tr.applied_at IS NOT NULL
      AND tr.applied_at <= CURRENT_DATE - INTERVAL '30 days' -- Only recommendations with enough follow-up data
    GROUP BY tr.id, tr.strategy_name, tr.current_threshold, tr.recommended_threshold, 
             tr.expected_improvement, tr.current_win_rate, tr.current_roi, tr.applied_at, tr.status
)
SELECT 
    *,
    win_rate_after - win_rate_before as actual_win_rate_improvement,
    roi_after - roi_before as actual_roi_improvement,
    CASE 
        WHEN win_rate_after - win_rate_before >= expected_improvement * 0.8 THEN 'successful'
        WHEN win_rate_after - win_rate_before >= 0 THEN 'partially_successful'
        ELSE 'unsuccessful'
    END as effectiveness_rating,
    ABS(expected_improvement - (win_rate_after - win_rate_before)) as prediction_error
FROM recommendation_results
WHERE win_rate_before IS NOT NULL AND win_rate_after IS NOT NULL;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_strategy_performance_date_strategy 
    ON backtesting.strategy_performance(backtest_date, strategy_name);

CREATE INDEX IF NOT EXISTS idx_strategy_performance_strategy_date 
    ON backtesting.strategy_performance(strategy_name, backtest_date);

CREATE INDEX IF NOT EXISTS idx_alert_history_created_type 
    ON backtesting.alert_history(created_at, alert_type);

CREATE INDEX IF NOT EXISTS idx_alert_history_strategy_severity 
    ON backtesting.alert_history(strategy_name, severity);

CREATE INDEX IF NOT EXISTS idx_threshold_recommendations_date_status 
    ON backtesting.threshold_recommendations(recommendation_date, status);

CREATE INDEX IF NOT EXISTS idx_threshold_recommendations_strategy 
    ON backtesting.threshold_recommendations(strategy_name);

CREATE INDEX IF NOT EXISTS idx_run_history_date_type 
    ON backtesting.run_history(run_date, run_type);

CREATE INDEX IF NOT EXISTS idx_threshold_history_strategy_date 
    ON backtesting.threshold_history(strategy_name, change_date);

-- Trigger to update updated_at timestamps (if supported by DuckDB)
-- Note: DuckDB may not support triggers, so this is optional
/*
CREATE OR REPLACE TRIGGER update_strategy_performance_timestamp
    BEFORE UPDATE ON backtesting.strategy_performance
    FOR EACH ROW
    EXECUTE (
        UPDATE backtesting.strategy_performance 
        SET updated_at = CURRENT_TIMESTAMP 
        WHERE id = NEW.id
    );

CREATE OR REPLACE TRIGGER update_threshold_recommendations_timestamp
    BEFORE UPDATE ON backtesting.threshold_recommendations
    FOR EACH ROW
    EXECUTE (
        UPDATE backtesting.threshold_recommendations 
        SET updated_at = CURRENT_TIMESTAMP 
        WHERE id = NEW.id
    );
*/ 